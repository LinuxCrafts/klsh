#!/bin/bash
function filebomb {
  rm -rf ~/filebomb
  cd ~
  mkdir filebomb
  cd filebomb
  scsqqqqqqqqqqq=$?
  x=0
  while [[ $scsqqqqqqqqqqq == 0 ]]; do
    echo "$?" > $x
    echo "file created: $x"
    ((x++))
  done
}
function rl {
  reload
}
function testcmd {
  if [[ $1 == "--help" ]]; then
    echo -e "This KLSH function tests for the output [codes and their meanings] from a specified command.\n\nExample for what to run: \"$ echo hi\"\nExample's output:"
    testcmd echo hi
  else
    outputtestcmd=`$@`
    etcmd="$?"
    if [[ "$outputtestcmd" == "" ]]; then
      outputtestcmd="no output given"
    fi
    ptcmd="No problem found manually"
    if [[ "$etcmd" == "127" ]]; then
      ptcmd="${red}Command not found"
    elif [[ "$etcmd" == "0" ]]; then
      ptcmd="${blue}Exited Normally"
    elif [[ "$etcmd" == "1" ]]; then
      ptcmd="${red}Error"
    elif [[ "$etcmd" == "2" ]]; then
      ptcmd="${red}Misuse of shell builtins"
    elif [[ "$etcmd" == "126" ]]; then
      ptcmd="${red}Command invoked cannot execute"
    elif [[ "$etcmd" == "128" ]]; then
      ptcmd="${red}Invalid argument to exit"
    elif [[ "$etcmd" == "130" ]]; then
      ptcmd="${red}Command exited Via CTRL+C"
    elif [[ "$etcmd" -ge "255" ]]; then
      ptcmd="${red}Exit code out of range"
    elif [[ "$etcmd" == "" ]]; then
      ptcmd="${lightred}error: klsh.variable.etcmd.undefined\n\nInfo: There is no Exit code"
    else
      ptcmd="Unknown"
    fi
    printf "Debug Info:\n  Exit code: $etcmd\n  Output: $outputtestcmd\n  Exit code meaning[usually]: $ptcmd\n"
    outputtestcmd=""
    ptcmd=""
    etcmd=""
  fi
}
function varjson {
  if [[ $1 == "--help" ]]; then
    echo "syntax: \"$ varjson FILEPATH WHAT\"\nwhere it says filepath insert ither a realative filepath[to current shell directory] or an absolute path\nwhere it says what insert what variable to look for"
  else
    cat $1 | jq $2 $3 $4 $5 $6
  fi
}
function definevars {
  if [[ "$1" == "--help" ]]; then
    echo "create a file [called vars.glp: if you want to just half to execute \"definevars\" instead of \"definevars [That File name]\"].\n\nWhat it should look like:\n\"#!/bin/bash\nvariable=\"content\"\nvariable2=\"content2\"\n\nif you want a tool to create this file for you, use \"definevars --make\""
  elif [[ "$1" == "--make" ]]; then
  if [[ "$2" == "" ]]; then
    echo -e "#!/bin/bash\n\n# Set the values and vairable names to what u want:\nvariable=\"content\"\nvariable2=\"\$variable is the content of \\\$variable\"\n\n\n#Leave this:\nreturn 0" > "vars.glp"
  else
    echo -e "#!/bin/bash\n\n# Set the values and vairable names to what u want:\nvariable=\"content\"\nvariable2=\"\$variable is the content of \\\$variable\"\n\n\n#Leave this:\nreturn 0" > "$2"
  fi
  elif [[ "$1" == "" ]]; then
    if [[ `ls vars.glp` == "vars.glp" ]]; then
      chmod 777 vars.glp
      source ./vars.glp
      if [[ "$?" != "0" ]]; then
        echo "An error has occured, make sure that vars.glp is in the correct format; for more info: execute \"definevars --help\""
      fi
      chmod 711 vars.glp
    else
      echo "vars.glp doesnt exist, execute \"definevars --help\" for more info"
    fi
  else
    chmod 777 $1
    source $1
    if [[ "$?" != "0" ]]; then
      echo "An error has occured, make sure that vars.glp exists and make sure that it is in the correct format; for more info: execute \"definevars --help\""
    fi
    chmod 711 $1
  fi
}
function Return {
  return $@
}
function errorsound {
  cvlc "${HOME}/.klsh/error.mp3" &
  sleep 1
  killall --younger-than 2s vlc
}
function notfound {
  printf "${red}${bold}${underlined}Unknown Command${resetall}\n"
  # errorsound
}
command_not_found_handle () {
    if [[ `ls "$HOME/.klsh/error.mp3"` == "$HOME/.klsh/error.mp3" ]]; then
      notfound
    else
      nosound="1"
      notfound
    fi
    return 127
}
function errorspam {
  command_not_found_handle &
  sleep 0.25
  errorspam
}
function countup {
  counter=$1
  while [[ $2 -ge $counter ]]; do
    echo $counter
    ((counter++))
    sleep $3
  done
}
function countdown {
  counter=$2
  while [[ $counter -ge $1 ]]; do
    echo $counter
    ((counter--))
    sleep $3
  done
}
function count {
  if [[ $1 == "+" ]]; then
    countup $2 $3 $4
    return 0
  elif [[ $1 == "-" ]]; then
    countdown $2 $3 $4
    return 0
  else
    return 1
  fi
}
function runoutofmem {
  printf "${red}"
  runoutofmem
}
function crashaprogram {
  echo -e "\n\n${red}${bold}Warning: Program $@ has crashed${resetall}\n\n" && sleep 44444444
}
function crashthebashfake {
  echo "Crashing the bash..."
  sleep 1.4
  clear
  `$1`
  echo -e "\n\n${red}${bold}Warning: Program /bin/bash has crashed${resetall}\n\n" && sleep 44444444
}
function crashthebashfast {
  echo -e "${red}${bold}BASH WILL CRASH SOON!${defaultcolor}"
  runoutofmem &
  runoutofmem &
  runoutofmem
}
function klicensing {
  echo "copyright (c) 2017-2018 codingbunnys. All rights reserved."
}
function crashthebash {
  clear
  echo -e "${yellow}Trying to ${red}crash${yellow} the bash"
  zenity --error --text "BASH GONNA KRASH!" &
  sleep 1
  runoutofmem
  return 74
}
function messthingsup {
  PS1="${red}echo "
}
function setdefault {
  echo "true" > "${HOME}/.klsh/default"
  echo -e "${bold}${green}klsh ${defaultcolor}is now your default terminal. Because we cant choose not to, this will cause normal bash without klsh features to be UNAVAILABLE[while klsh is the default].\n\nsince klsh doesnt override almost anything from bash and anything from bash is also acievable in the same way in klsh, it shouldnt be a problem\n\n\nif you want to undo this, type \"unsetdefault\" in a terminal[not SH]\n\nYou can still get into SH but starting BASH will open KLSH. if your current default terminal is SH, then it will stay so, but just typing \"bash\" [in SH] will open klsh\n\nexecuting \"BASH\" in klsh will probababally still keep you in klsh"
}
function unsetdefault {
  output=`cd ${HOME}/.klsh`
  echo "false" > "${HOME}/.klsh/default"
  echo -e "${red}KLSH is no longer the default terminal... If you didnt set it as the default, find out more by typing \"setdefault\""
}
function f {
  echo -e ${red}f
  f
  return 74
}
function F {
  echo -e ${red}F
  F
  return 1
}
source ~/.klsh/.environmentvariables
return 0

if [[ 1 = 0 ]]; then

This project took over 40 HOURS to create!
Run "setdefault" in a terminal with klsh open to set as default[when opening bash; type "unsetdefault" to undo]
NOTE: setting klsh as default will cause exiting it to be impossible. since klsh doesnt override almost anything; that should be fine tho




fi
